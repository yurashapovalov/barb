# ADR-008: AST парсер вместо eval()

## Контекст

Query engine вычисляет выражения типа `high - low`, `close > open and volume > 1000`, `rolling_mean(close, 20)`. Нужен способ превращать строку в pandas операцию.

## Решение

Python `ast.parse()` + whitelist допустимых узлов + своя функция `_eval_node()`. Никакого `eval()`.

```python
tree = ast.parse(expr, mode="eval")
result = _eval_node(tree.body, df, functions)
```

Разрешённые узлы: `Name`, `Constant`, `BinOp`, `Compare`, `BoolOp`, `UnaryOp`, `Call`, `IfExp`, `Attribute`. Всё остальное — ошибка.

## Почему не eval()

- Выражения приходят от LLM. LLM может сгенерировать `__import__('os').system('rm -rf /')`. С eval() это выполнится.
- AST whitelist гарантирует что выполнятся только арифметика, сравнения и функции из реестра.
- Функции зарегистрированы в `FUNCTIONS` dict — вызвать можно только то что явно добавлено.

## Почему не свой DSL / парсер

- Python AST уже умеет парсить `high - low > 100 and volume > 1000` — зачем писать свой парсер?
- Синтаксис выражений интуитивен для LLM — это просто Python выражения
- Меньше кода, меньше багов

## Последствия

- Безопасно: произвольный код не выполнится
- Ограничено: нельзя использовать всё что есть в Python (циклы, присваивания, импорты)
- Ошибки парсинга понятные: `ExpressionError` с указанием выражения и шага
