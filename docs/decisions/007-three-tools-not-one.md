# ADR-007: Три тула вместо одного

## Контекст

Gemini использует function calling для работы с данными. Нужно было решить сколько tools давать модели и как разделить ответственность.

## Решение

Три тула с чёткими ролями:

1. **understand_question** — возвращает capabilities и limitations движка. Gemini вызывает перед запросом чтобы понять что возможно.
2. **get_query_reference** — возвращает полную спецификацию: формат JSON, все 40+ функций, примеры. Инструкция по написанию запросов.
3. **execute_query** — принимает JSON запрос, выполняет через interpreter, возвращает результат.

## Почему не один тул "execute_query"

- Gemini не знает формат запроса. Без reference он будет угадывать JSON структуру и ошибаться.
- Без understand Gemini не знает что движок может, а что нет. Будет пытаться делать JOINы или subqueries которых нет.
- Разделение позволяет Gemini сначала понять задачу, потом изучить формат, потом выполнить. Как человек: сначала думаешь, потом смотришь документацию, потом пишешь код.

## Почему не запечь reference в system prompt

- Reference — это ~3000 токенов (все функции, формат, примеры). В system prompt это лишние токены на каждый запрос.
- Gemini вызывает reference один раз в начале разговора, дальше помнит из контекста.
- Implicit caching Gemini всё равно кэширует system prompt, но чем он легче — тем лучше.

## Как работает цикл

```
Gemini получает вопрос
  → вызывает understand_question (что возможно?)
  → вызывает get_query_reference (как писать запрос?)
  → вызывает execute_query (выполнить)
  → если ошибка — читает error, step, expression, пробует ещё раз
  → максимум 5 раундов
  → возвращает текстовый ответ
```

## Последствия

- Типичный вопрос = 2-3 раунда tool calls (understand + reference на первый вопрос, потом только execute)
- Больше раундов = больше токенов. Но качество ответов выше чем с одним тулом
- Добавление нового тула — добавить declaration + handler в `assistant/tools/`
