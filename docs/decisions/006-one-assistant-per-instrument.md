# ADR-006: Один Assistant на инструмент

## Контекст

Assistant загружает данные инструмента (parquet), конфигурацию сессий, создаёт Gemini клиент. Нужно было решить lifecycle — создавать на каждый запрос или кэшировать.

## Решение

Один `Assistant` на инструмент, кэшированный через `@lru_cache`. Переиспользуется между всеми запросами.

```python
@lru_cache
def _get_assistant(instrument: str) -> Assistant:
    return Assistant(api_key=..., instrument=instrument, df=load_data(instrument), ...)
```

## Почему так

- DataFrame загружается один раз (NQ.parquet = 62MB) — не на каждый запрос
- Gemini клиент переиспользуется — не создаём новое соединение каждый раз
- Конфигурация сессий статична — не меняется в runtime
- `lru_cache` по instrument — когда добавим ES, YM, каждый получит свой экземпляр с нужными данными и сессиями

## Альтернативы

- Создавать Assistant на каждый запрос — простор, но медленно (загрузка данных)
- Глобальный синглтон на все инструменты — не масштабируется на несколько инструментов
- Dependency injection через FastAPI Depends — избыточно для статичного объекта

## Последствия

- Первый запрос к инструменту медленнее (загрузка данных + создание клиента)
- При обновлении данных нужен рестарт сервера (или сброс кэша)
- Память: один DataFrame на инструмент в RAM на весь lifecycle процесса
