# Display Columns: контроль отображения результатов

## Проблема

Модель контролирует что считать (`map`, `where`, `select`), но не контролирует что показывать пользователю. Результат содержит всё что есть в DataFrame — автоколонки (`date`, OHLCV, `volume`) + map-колонки. Это создаёт несколько проблем.

### 1. OHLCV шум

Вопрос: "покажи торговые дни январь 2026"
Ожидание: дата, день недели
Реальность: `date | open | high | low | close | volume | день | дата`

OHLCV не нужны для ответа на этот вопрос. Но они всегда включаются потому что `_prepare_for_output()` выводит все колонки DataFrame.

### 2. Дублирование колонок

`_prepare_for_output()` автоматически создаёт `date` из DatetimeIndex. Модель не знает об этом и маппит `"дата": "date()"`. Результат: две колонки с одинаковыми данными.

### 3. Смешанные языки

Автоколонки всегда на английском (`date`, `open`, `close`). Map-колонки на языке пользователя (`дата`, `день`). Пользователь видит кашу: `date | open | high | low | close | volume | день | дата`.

### 4. Модель не знает правил вывода

- Не знает что `date` генерируется автоматически
- Не знает что OHLCV всегда включаются
- Не знает что map-колонки окажутся после OHLCV
- Не может убрать ненужные колонки из вывода

## Текущая архитектура

```
Query (map, where, select...)
    ↓
Interpreter pipeline (9 шагов)
    ↓
_prepare_for_output()
  - split timestamp → date (+time)
  - _order_columns(): date, time, group_keys, OHLC, volume, map, remaining
    ↓
_serialize_records()
    ↓
Все колонки → UI
```

Нет слоя между "что посчитали" и "что показываем".

## Контекстная полезность

Не всегда нужно убирать все лишние колонки. Если пользователь спрашивает "покажи торговые дни" — может быть полезно показать не только дату, но и что-то контекстно релевантное: change%, range, объём. Не всё OHLCV, а осмысленные метрики.

Примеры:
- "торговые дни" → дата, день недели, change%, volume (контекст)
- "дни когда упало больше 2%" → дата, close, change% (ответ на вопрос)
- "средний gap по дням недели" → день, mean_gap (только агрегат)
- "покажи данные за март" → дата, OHLCV, volume (все данные уместны)

Решение о том какие колонки полезны — это работа модели (она понимает контекст вопроса), а не интерпретатора.

## Два вопроса в одном

1. **Вычисление** — `map`, `where`, `group_by`, `select` работают на внутренних колонках. Движок, работает хорошо.
2. **Отображение** — какие колонки показать, в каком порядке, с какими названиями. Сейчас этого контроля нет.

## Возможные подходы

### A. Поле `display` в запросе

Модель явно перечисляет колонки для UI с человеческими названиями:

```json
{
  "map": {"chg": "change_pct()", "dow": "dayname()"},
  "display": [
    {"key": "date", "label": "Дата"},
    {"key": "dow", "label": "День недели"},
    {"key": "close", "label": "Закрытие"},
    {"key": "chg", "label": "Изменение %"}
  ]
}
```

Плюсы: полный контроль, названия на языке пользователя, порядок определён.
Минусы: усложняет запрос, модель может ошибаться в key names, больше токенов.

### B. Поле `columns` (список колонок без переименования)

```json
{
  "map": {"change_pct": "change_pct()", "dow": "dayname()"},
  "columns": ["date", "dow", "close", "change_pct"]
}
```

Плюсы: проще чем `display`, фильтрует ненужные колонки.
Минусы: названия остаются внутренними (`date`, не `Дата`), не решает проблему языка.

### C. Переименование на фронтенде

Бэкенд отдаёт внутренние имена, фронтенд переводит через словарь: `date` → `Дата`, `close` → `Закрытие` (на основе locale пользователя).

Плюсы: бэкенд не меняется, locale-aware.
Минусы: map-колонки не переведёшь (они произвольные), нужен словарь для каждого языка.

### D. Гибрид: `columns` + умные labels

Модель выбирает какие колонки показывать (`columns`). Бэкенд отвечает за порядок. Названия: map-колонки уже именованы моделью, авто-колонки переводятся через словарь на фронте.

### E. Модель сама решает через map

Не менять движок. Научить модель через промпт: "не маппь date() для отображения — колонка date создаётся автоматически. OHLCV тоже. Маппь только вычисляемые колонки. Давай map-колонкам понятные имена."

Плюсы: ноль изменений в коде.
Минусы: модель не может убрать OHLCV. Всё равно будут лишние колонки.

## Решения (принятые)

### Шаг 1: reorder (сделано)

Map-колонки перед OHLCV в `_prepare_for_output()`:
```
date → time → group_keys → map_columns → OHLC → volume → remaining
```
Derived data важнее сырых свечей. Безопасно, не ломает вычисления.

### Шаг 2: projection через `columns` (план)

Optional поле `columns: string[]` в query. Модель перечисляет какие колонки показать, в каком порядке.

```json
{
  "map": {"день_недели": "dayname()", "изменение": "change_pct(close,1)"},
  "columns": ["date", "день_недели", "close", "изменение"]
}
```

**Реализация:**
- `barb/validation.py` — валидация: `columns` = optional list of strings
- `barb/interpreter.py` `_prepare_for_output()` — если `columns` есть, filter + reorder по нему. Unknown column → ignore (не ломать запрос)
- `assistant/tools/__init__.py` — добавить `columns` в input_schema
- Промпт — правило: использовать `columns` для контроля отображения. OHLCV только когда вопрос про свечи

**Зачем:**
- UX — показывать только релевантные колонки
- Лицензия — FirstRate запрещает перепродажу raw data. OHLCV в чистом виде = raw candle data. Enriched результат (date + indicators) = derived data

**Когда:** после оценки шага 1 в проде. Если reorder + промптовые правила покрывают 90% кейсов — можно отложить.

## Закрытые вопросы

- **Кто решает что показывать?** Модель. Она понимает контекст вопроса. Движок не может угадать.
- **Smart defaults (авто-скрытие OHLCV)?** Отвергнуто. Edge cases (gap → нужен open, range → нужны high/low) делают smart defaults хрупкими без парсинга AST.
- **group_by?** Там OHLCV и так не появляются — проблема только для table результатов.
- **Промпт без `columns`?** Частично работает (модель не маппит date(), добавляет dayname()). Но не может убрать OHLCV.
